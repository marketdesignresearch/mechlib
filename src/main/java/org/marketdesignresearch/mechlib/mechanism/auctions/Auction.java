package org.marketdesignresearch.mechlib.mechanism.auctions;

import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.UUID;

import org.marketdesignresearch.mechlib.core.Domain;
import org.marketdesignresearch.mechlib.core.Good;
import org.marketdesignresearch.mechlib.core.Outcome;
import org.marketdesignresearch.mechlib.core.bid.bundle.BundleValueBids;
import org.marketdesignresearch.mechlib.core.bidder.Bidder;
import org.marketdesignresearch.mechlib.core.bidder.random.BidderRandom;
import org.marketdesignresearch.mechlib.core.bidder.strategy.InteractionStrategy;
import org.marketdesignresearch.mechlib.instrumentation.AuctionInstrumentationable;
import org.marketdesignresearch.mechlib.instrumentation.MipInstrumentation;
import org.marketdesignresearch.mechlib.mechanism.Mechanism;
import org.marketdesignresearch.mechlib.mechanism.auctions.interactions.Interaction;
import org.marketdesignresearch.mechlib.outcomerules.OutcomeRuleGenerator;
import org.springframework.data.annotation.PersistenceConstructor;

import com.google.common.base.Preconditions;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;

/**
 * An (iterative) bundle value bid Auction. An auction is build with different consecutive AuctionPhases.
 * An AuctionPhase can consist of different rounds. Each AuctionPhase is responsible to drive the auction.
 * Auction Rounds are following this sequence:
 * 
 * 1. The AuctionPhase is called to create an AuctionRoundBuilder that is responsible for this round
 * 	  The AuctionRoundBuilder holds an interaction for each bidder that is passed through by the auction
 * 2. Each bidder can access the interaction and submit bids
 * 3. (optional) by {@link #advanceRound()} the proposed bids will be submitted if no bids were submited before
 *    for a bidder (which were generated by a bidders strategy {@link InteractionStrategy} and close the round.
 * 4. The AuctionRound can be also just closed by {@link #closeRound()} without submitting the proposed bids
 * 5. The AuctionRoundBuilder is called to close this round and create an AuctionRound which is stored and
 *    accessible directly from the Auction.
 * 6. If the AuctionPhase indicates that no more rounds follow the next AuctionPhase is activiated
 *    If no AuctionPhase is left the Auction closes.
 * 
 * All rounds are stored in the auction round list {@linkplain #getRound(int)} with the number of rounds
 * {@linkplain #getNumberOfRounds()}. An AuctionRound might hold all relevant details including submitted
 * bids. 
 * 
 * Each auction can be reset to any previous round and continued form there {@link #resetToRound(int)}. Note that 
 * therefore all state should be captured with an AuctionRound. An AuctionPhase should never contain any state 
 * information because an AuctionPhase is not reset!
 * 
 * Note that an Auction holds a round dependant Random Object that might be used to in an AuctionPhase,
 * AuctionRoundBuilder or in an InteractionStrategy. When no manual bids are submitted (i.e. all bidders use
 * solely an InteractionStrategy and the round advances with {@link #advanceRound()} the outcome of this 
 * auction should be completely reproducible. (Also if the auction is {@link #resetToRound(int)} and altered 
 * (i.e. changed an upcoming AuctionPhase) the result will be the same, as if the auction was run from the 
 * beginning directly. 
 * 
 * If you are interested in creating an auction with exact value bids you may consider extending {@link ExactValueAuction}.
 * 
 * @author Manuel Beyeler
 * 
 * FIXME: MipInstrumetation should be handled properly. 
 *
 * @param <BB> the bid type used in this auction
 */
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Slf4j
public abstract class Auction<BB extends BundleValueBids<?>> extends Mechanism implements AuctionInstrumentationable {

	/**
	 * Default max number of rounds
	 * @see #maxRounds
	 */
	private static int DEFAULT_MAX_ROUNDS = 0;

	/**
	 * The domain in which this auction runs
	 */
	@Getter
	private final Domain domain;
	/**
	 * The default OutcomeRuleGenerator
	 */
	@Getter
	private final OutcomeRuleGenerator outcomeRuleGenerator;

	/**
	 * The seed used to generate the round random objects
	 */
	private Long seed;

	/**
	 * Maximum number of rounds in this auction
	 * 
	 * If maxRounds equals to 0, the number of rounds is infinite and the auction
	 * terminates after all auction phases have completed successfully.
	 */
	@Getter
	@Setter
	private int maxRounds = DEFAULT_MAX_ROUNDS;

	/**
	 * The List of Rounds that hold most state of the auction including the bids
	 */
	protected List<AuctionRound<BB>> rounds = new ArrayList<>();

	/**
	 * The current AuctionPhase (starting from 0)
	 */
	@Getter
	protected int currentPhaseNumber = 0;
	/**
	 * The current round of the active AuctionPhase (starting from 0).
	 * For each new AuctionPhase this counter will be reset.
	 */
	@Getter
	protected int currentPhaseRoundNumber = 0;
	/**
	 * The list of AuctionPhases
	 */
	protected List<AuctionPhase<BB>> phases = new ArrayList<>();

	/**
	 * The AuctionRoundBuilder of the current running round.
	 * This attribute will be set to null if the auction has finished
	 */
	protected AuctionRoundBuilder<BB> current;

	/**
	 * Creates a new Auction and starts the first round. More AuctionPhases can be added later.
	 * 
	 * This Constructor sets a random seed for the round random generator. Results of Auctions are
	 * threfore not reproducible if the round random object is used any time.
	 * 
	 * @param domain the domain in which this auction should run
	 * @param outcomeRuleGenerator the default outcome rule generator
	 * @param firstPhase the first phase of this auction
	 */
	public Auction(Domain domain, OutcomeRuleGenerator outcomeRuleGenerator, AuctionPhase<BB> firstPhase) {
		this(domain, outcomeRuleGenerator, firstPhase, null);
	}

	/**
	 * Creates a new Auction and starts the first round. More AuctionPhases can be added later.
	 * 
	 * @param domain the domain in which this auction should run
	 * @param outcomeRuleGenerator the default outcome rule generator
	 * @param firstPhase the first phase of this auction
	 * @param seed the seed to create the round random objects from
	 */
	public Auction(Domain domain, OutcomeRuleGenerator outcomeRuleGenerator, AuctionPhase<BB> firstPhase, Long seed) {
		this.domain = domain;
		this.seed = seed;
		this.outcomeRuleGenerator = outcomeRuleGenerator;
		this.phases.add(firstPhase);
		this.prepareNextAuctionRoundBuilder();
	}

	/**
	 * Persistence constructor
	 * @param domain the domain
	 * @param outcomeRuleGenerator the outcomerule generator
	 * @param current the current AuctionRoundBuilder
	 */
	@PersistenceConstructor
	protected Auction(Domain domain, OutcomeRuleGenerator outcomeRuleGenerator, AuctionRoundBuilder<BB> current) {
		this.domain = domain;
		this.outcomeRuleGenerator = outcomeRuleGenerator;
		this.current = current;
		current.setAuction(this);
	}

	/**
	 * Adds an additional AuctionPhase at the end
	 * 
	 * @param auctionPhase the AuctionPhase to add
	 * @return true
	 */
	protected boolean addAuctionPhase(AuctionPhase<BB> auctionPhase) {
		Preconditions.checkArgument(!this.finished());
		return this.phases.add(auctionPhase);
	}

	/**
	 * @return the current active AuctionPhase
	 */
	protected AuctionPhase<BB> getCurrentPhase() {
		return this.phases.get(this.currentPhaseNumber);
	}

	/**
	 * Gets the interaction of the current round for the given bidder
	 * @param b the bidder
	 * @return the interaction this bidder should take in this round
	 */
	public Interaction getCurrentInteraction(Bidder b) {
		Preconditions.checkArgument(!this.finished());
		return this.current.getInteractions().get(b.getId());
	}

	/**
	 * Gets the bidder which corresponds to the given UUID
	 * @param id the UUID of this bidder
	 * @return the bidder object
	 * @throws NoSuchElementException if there is no bidder in the domain of this auction with the given UUID
	 */
	public Bidder getBidder(UUID id) {
		return domain.getBidders().stream().filter(b -> b.getId().equals(id)).findFirst()
				.orElseThrow(NoSuchElementException::new);
	}

	/**
	 * Get the good with the given name
	 * @param name the name of the good
	 * @return the good object
	 * @throws NoSuchElementException if there is no good in the domain of this auction with the given name
	 */
	public Good getGood(String name) {
		return domain.getGoods().stream().filter(b -> b.getName().equals(name)).findFirst()
				.orElseThrow(NoSuchElementException::new);
	}

	/**
	 * Get the good with the given UUID
	 * @param id the UUID of the good
	 * @return the good object
	 * @throws NoSuchElementException if there is no good in the domain of this auction with the given UUID
	 */
	public Good getGood(UUID id) {
		return domain.getGoods().stream().filter(b -> b.getUuid().equals(id)).findFirst()
				.orElseThrow(NoSuchElementException::new);
	}

	/**
	 * Checks wheather this auction has finished
	 * @return true if this auction has finished, false otherwise
	 */
	public boolean finished() {
		return this.current == null;
	}

	/**
	 * This fills up the not-yet-submitted bids and closes the round
	 */
	public void advanceRound() {
		Preconditions.checkArgument(!this.finished());
		this.current.getInteractions().forEach((b, i) -> i.submitProposedBid());
		closeRound();
	}

	/**
	 * This closes the round and initializes the next round if there is any.
	 */
	public void closeRound() {
		Preconditions.checkState(!this.finished());

		AuctionRound<BB> round = this.current.build();
		getAuctionInstrumentation().postRound(round);
		rounds.add(round);
		BidderRandom.INSTANCE.setRandom(null);
		prepareNextAuctionRoundBuilder();
	}

	/**
	 * Creates the AuctionRoundBuilder for the next round. If the current
	 * AuctionPhase has finished it moves to the next AuctionPhase or it
	 * closes the Auction if there is no next AuctionPhase.
	 */
	protected void prepareNextAuctionRoundBuilder() {
		// Move to next round if phase has finished
		while(this.phases.size() > this.currentPhaseNumber && this.getCurrentPhase().phaseFinished(this)) {
			this.currentPhaseNumber++;
			this.currentPhaseRoundNumber = 0;
		}
		// Stop if last phase has finished or maxRounds was reached
		if ((this.phases.size() == this.currentPhaseNumber)
				|| (maxRounds > 0 && getNumberOfRounds() >= maxRounds)) {
			current = null;
		// Start next round
		} else {
			log.info("Starting round {}", this.getNumberOfRounds() + 1);
			this.prepareBidderRoundRandom();
			current = this.getCurrentPhase().createNextRoundBuilder(this);
			this.currentPhaseRoundNumber++;
		}
	}

	private void prepareBidderRoundRandom() {
		if (seed == null) {
			log.warn("No random seed provided. Please provide a seed to make experiments repeatable");
			seed = new Random().nextLong();
		}
		
		Random init = new Random(seed);
		long roundSeed = init.nextLong();
		for (int i = 0; i < this.getNumberOfRounds(); i++) {
			roundSeed = init.nextLong();
		}
		
		BidderRandom.INSTANCE.setRandom(new Random(roundSeed));
	}

	/**
	 * Returns all bids that were submitted at or before the given round.
	 * @param round the round number
	 * @return aggregated bids
	 */
	public BB getAggregatedBidsAt(int round) {
		Preconditions.checkArgument(round >= 0 && round < rounds.size());
		return rounds.subList(0, round + 1).stream().map(AuctionRound::getBids).reduce(this::join)
				.orElse(this.createEmptyBids());
	}

	/**
	 * Returns the bids that were submitted in this round only.
	 * @param round the round number
	 * @return the bids submitted in the given round
	 */
	public BB getBidsAt(int round) {
		Preconditions.checkArgument(round >= 0 && round < rounds.size());
		return rounds.get(round).getBids();
	}

	/**
	 * Returns all submitted bids so far. At the end of the auction this will 
	 * return all bids submitted during the auction.
	 * @return aggregation of all bids submitted so far
	 */
	public BB getLatestAggregatedBids() {
		if (rounds.size() == 0)
			return this.createEmptyBids();
		return getAggregatedBidsAt(rounds.size() - 1);
	}

	/**
	 * Returns the bids of the last completed round. To access the bids already
	 * made in the current active round you need to access them through the 
	 * interactions
	 * @return the bids of the last completed round
	 * @see #getCurrentInteraction(Bidder)
	 */
	public BB getLatestBids() {
		if (rounds.size() == 0)
			return this.createEmptyBids();
		return getBidsAt(rounds.size() - 1);
	}

	/**
	 * Helper method to avoid type casts. Joins two concrete bids
	 * @param b1 bid one
	 * @param b2 bid two
	 * @return joined bids
	 */
	protected abstract BB join(BB b1, BB b2);

	/**
	 * Creates an empty bid for the concrete bid type of this auction.
	 * @return
	 */
	protected abstract BB createEmptyBids();

	/**
	 * Get the round with the given index. Note that the first round has index 0
	 * 
	 * @param index The index of the requested round.
	 * @return the round if it exists
	 */
	public AuctionRound<BB> getRound(int index) {
		Preconditions.checkArgument(index >= 0 && index < rounds.size());
		return rounds.get(index);
	}

	/**
	 * Get the round object of the last completed round
	 * @return the last completed round
	 */
	public AuctionRound<BB> getLastRound() {
		return this.getRound(this.getNumberOfRounds() - 1);
	}

	/**
	 * Get the number of complete rounds. If the auction is not finished round
	 * getNumberOfRounds() + 1 is running at the moment.
	 * 
	 * @return number of completed rounds
	 */
	public int getNumberOfRounds() {
		return rounds.size();
	}

	/**
	 * Reset the auction such that it is in the state of executing the given round.
	 * (I.e. {@link #getNumberOfRounds()} will return round-1 after this method has
	 * executed.
	 * 
	 * @param round the round that should be executed next by this auction
	 */
	public void resetToRound(int round) {
		Preconditions.checkArgument(round >= 1 && round <= rounds.size() + 1);
		rounds = rounds.subList(0, round - 1);
		if(round == 1) {
			this.currentPhaseNumber = 0;
			this.currentPhaseRoundNumber = 0;
		} else {
			this.currentPhaseNumber = this.getLastRound().getAuctionPhaseNumber();
			this.currentPhaseRoundNumber = this.getLastRound().getAuctionPhaseRoundNumber();
		}
		this.prepareNextAuctionRoundBuilder();
	}

	/**
	 * By default, the bids for the auction results are aggregated in each round
	 */
	public Outcome getOutcomeAtRound(int index) {
		return this.getOutcomeAtRound(this.getOutcomeRuleGenerator(), index);
	}

	/**
	 * By default, the bids for the auction results are aggregated in each round
	 * @param generator the OutcomeRuleGenerator that should be used to generate the outcome
	 * @param index the round number
	 * @return the outcome
	 */
	public Outcome getOutcomeAtRound(OutcomeRuleGenerator generator, int index) {
		return generator.getOutcomeRule(getAggregatedBidsAt(index), getMipInstrumentation()).getOutcome();
	}

	/**
	 * Returns the maximum number of bids submitted by any bidder.
	 */
	public int getMaximumSubmittedBids() {
		return this
				.getDomain().getBidders().stream().map(b -> this.rounds.stream()
						.map(r -> r.getBids().getBid(b).getBundleBids().size()).reduce(Integer::sum).orElse(0))
				.reduce(Integer::max).orElse(0);
	}

	/**
	 * By default, the outcome is the last round's outcome, because the bids are
	 * aggregated. This has to be overridden, e.g., for the sequential auction
	 */
	@Override
	public Outcome getOutcome() {
		return this.getOutcome(this.getOutcomeRuleGenerator());
	}

	/**
	 * By default, the outcome is the last round's outcome, because the bids are
	 * aggregated. This has to be overridden, e.g., for the sequential auction
	 * @param generator the OutcomeRuleGenerator that is used to compute the outcome
	 * @return the outcome
	 */
	public Outcome getOutcome(OutcomeRuleGenerator generator) {
		if (rounds.size() == 0)
			return Outcome.NONE;
		return getOutcomeAtRound(generator, rounds.size() - 1);
	}

	/**
	 * Computes the temporary result including bids submitted in the current round.
	 * @return the outcome
	 */
	public Outcome getTemporaryResult() {
		return this.getTemporaryResult(this.getOutcomeRuleGenerator());
	}

	/**
	 * Computes the temporary result including bids submitted in the current round using the given 
	 * OutcomeRuleGenerator.
	 * @param generator The OutcomeRuleGenerator that is used to compute the outcome
	 * @return the outcome
	 */
	public Outcome getTemporaryResult(OutcomeRuleGenerator generator) {
		return generator.getOutcomeRule(this.getLatestAggregatedBids().join(current.getTemporaryBids())).getOutcome();
	}

	/**
	 * Type String of the curren AuctionPhase
	 * @param i queried phase number (starting from 0)
	 * @return the type name of the current phase
	 */
	public String getPhaseType(int i) {
		return this.phases.get(i).getType();
	}

	/**
	 * @return the number of phases in this auction
	 */
	public int getNumberOfPhases() {
		return this.phases.size();
	}

	// region instrumentation
	@Override
	public void setMipInstrumentation(MipInstrumentation mipInstrumentation) {
		super.setMipInstrumentation(mipInstrumentation);
		this.domain.setMipInstrumentation(mipInstrumentation);
	}
	// endregion
}
